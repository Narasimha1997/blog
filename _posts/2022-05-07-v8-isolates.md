---
title: Function as a Service using V8 JavaScript engine's built-in multi-tenancy and isolation
published: true
---
One of the most underrated and least known features of Google's v8 javascript engine is it's ability to create and run untrusted code in a secure and isolated sandbox called `Isolate`. A single instance of V8 can create and run hundreds of such isolates provided enough memory and compute, while this feature is useful for web browsers (when we open a new tab in the web browser a new V8 isolate is created for that tab - this ensures isolation and security across multiple browser tabs), the same can also be used at the server side to run JavaScript compute instances inside thin pseudo-virtual instances powered by V8 isolates. This can be useful in places where people are ready to compromise on the security offered Virtual Machines and Containers in order to improve the throughput (number of functions executed per second). V8 isolates offer isolation between running JavaScript instances - thus each function that is invoked in a isolate has it's own heap, execution stack, garbage collector and separate contexts of execution, which offers thin level of security between multiple tenants.

## V8 isolates
As stated earlier, V8 isolates are like light-weight virtual instances orchestrated by V8 engine, each isolate has it's own Heap allocator, heap allocation memory, execution stack (handle scope) and garbage collector and each V8 isolate is bounded to a thread so only one thread can access the isolate at a time - these ingredients provide all the necessary requirements to execute JavaScript functions completely isolated from each other, it is also possible to have multiple object groups within the same isolate called `Contexts`. Here is the definition of isolates as per Cloudflare:

> 

    V8 orchestrates isolates: lightweight contexts that group variables with the code allowed to mutate them. You could even consider an isolate a “sandbox” for your function to run in.

    A single runtime can run hundreds or thousands of isolates, seamlessly switching between them. Each isolate’s memory is completely isolated, so each piece of code is protected from other untrusted or user-written code on the runtime. Isolates are also designed to start very quickly. Instead of creating a virtual machine for each function, an isolate is created within an existing environment. This model eliminates the cold starts of the virtual machine model.

### Why isolates are faster when compared to VMs, Containers and processes for FaaS?
In FaaS model, each function is usually invoked in a separate "isolated executor" - to provide security, here the "isolated executor" can be either a Virtual machine, a container or a process. 
1. VMs offer highest degree of isolation - a VM runs it's own Operating system inside and all the interactions with hardware and host operating system are controlled via a secure hypervisor, despite providing high security VMs are slow to spin up and we cannot put lot of VMs on the same hardware because of the memory requirements involved in running it's own compute stack from the ground up. 
2. Containers offer process group level isolation on top of the same operating system, each container has it's own root file system, virtual network IP and it is also possible for containers on the same host to connect together via a virtual network overlay. Containers can also be assigned dedicated CPU, memory quotas and fine-grained access to other hardware resources using `cgroups`. When compared to VMs, containers are faster to create and destroy but offers less security (as all containers use the same Operating system, if a malicious code is able to escape the container, it can take control of host operating system and affect other containers). While containers are good solution for FaaS and has worked out well in many cases, it is still a overhead for high velocity FaaS workloads because creating containers require tightly coupled coordination with operating system. 
3. Process is a basic level of task as seen by operating system, each process has it's own virtual address space, file-descriptors and threads - while isolation still exists, it is not as strong as containers because processes share the same host file-system and has unbounded access to all the host hardware resources. When compared to containers, processes are much faster to create and destroy, but after a certain limit, forking of new processes and context switches involved while scheduling these processes becomes a bottleneck.
4. Isolates: As mentioned previously, isolates are virtual units of execution inside the same process, each bounded to a specific thread of execution. Isolates are built on top of raw threads that share the same heap memory at the process level, but the isolation is virtually created by using high-level constructs that are required to execute JavaScript code instances separately. Unlike processes, isolates are created and managed in the user-space by the V8 instance which runs as a process this greatly reduces the forking overhead, the overhead of context switching is also less because it is faster to context-switch threads than processes.

To conclude, scalability is inversely proportional to the level of isolation required. The level of isolation required depends on the type of workloads executed by the FaaS platform. 

### When isolates are useful?
From the previous section, it is clear that we need to make a trade-off between isolation and performance, so isolates can be useful where performance matters and the workloads doesn't demand much isolation. Isolates can be used when:
1. Functions are very short-lived, event-driven and real-time response is important. (Because isolates have very less cold-start time)
2. Large number of functions needs to be served with minimum memory (Because isolates consume lot less memory and CPU compute time for cold-start)
3. Functions don't make system calls and just manipulate data - in other words they take input and return the output without depending on I/O or network. (If you care about security, this might be an important requirement because isolates don't offer any protection at operating system level, however this can be mitigated some measures at the platform level)

It is also possible to use VMs, containers and isolates together. For example - 
1. On a 64 vCPU machine, create two VMs - each with 32 vCPUs.
2. Each VM runs 4 containers.
3. Each container runs a process.
4. Process has a V8 instance embedded inside an application that can take FaaS requests, execute functions and return output by spinning up hundreds of isolates.

## Trying out JavaScript V8 isolates with Rust:
